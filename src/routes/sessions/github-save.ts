import { Hono } from "hono";
import { ANALYSIS_TYPE } from "../../constants.ts";
import { now } from "../../db/helpers.ts";
import { db } from "../../db/index.ts";
import { generatePRDMarkdown } from "../../helpers/format.ts";
import { saveToGitHub } from "../../helpers/github.ts";
import { getOwnedSession, isResponse } from "../../helpers/session-ownership.ts";
import { callClaude, extractText, MODEL_FAST } from "../../llm.ts";
import type { AppEnv } from "../../types.ts";

export const githubSaveRoutes = new Hono<AppEnv>();

// --- ユーティリティ ---

const LLM_INPUT_MAX_CHARS = 6000;

/** spec オブジェクトから raw テキストを抽出する */
export function extractSpecRaw(spec: Record<string, unknown>): string {
  const inner = typeof spec.spec === "object" && spec.spec !== null ? (spec.spec as Record<string, unknown>) : spec;
  return typeof inner.raw === "string" ? inner.raw : "";
}

// --- ファイル生成ヘルパー ---

/** LLM でプロダクトサマリ付き README を生成する */
export async function generateReadme(theme: string, prdMarkdown: string, specRaw: string): Promise<string> {
  const systemPrompt = `You are a technical writer. Write a concise, professional README.md for a GitHub repository.
IMPORTANT: Respond in the SAME LANGUAGE as the input PRD.
Output ONLY the README content in Markdown. No code fences around the entire output.`;

  const truncatedPrd = prdMarkdown.slice(0, LLM_INPUT_MAX_CHARS);
  const truncatedSpec = specRaw.slice(0, LLM_INPUT_MAX_CHARS);

  const userPrompt = `以下の PRD と実装仕様から、GitHub リポジトリの README.md を生成してください。

テーマ: ${theme}

## 要件
1. プロジェクト名をタイトルに
2. 2〜3 文のプロダクト概要（問題と解決策を簡潔に）
3. 主要機能のリスト（箇条書き）
4. リポジトリに含まれるファイルの説明
5. AI コーディングエージェントでの使い方（AGENT.md と Plan.md を活用する手順）
6. 最後に "Generated by [DeepForm](https://deepform.exe.xyz)" のフッター

## PRD
${truncatedPrd}

## 実装仕様
${truncatedSpec}`;

  try {
    const response = await callClaude([{ role: "user", content: userPrompt }], systemPrompt, 2048, MODEL_FAST);
    const text = extractText(response).trim();
    if (text.length > 100 && text.startsWith("#")) return text;
  } catch (e) {
    console.warn("README generation failed, using fallback:", e);
  }

  // フォールバック: 静的テンプレート
  return generateReadmeFallback(theme);
}

function generateReadmeFallback(theme: string): string {
  return `# ${theme}

> Generated by [DeepForm](https://deepform.exe.xyz)

## Files

| File | Description |
|------|-------------|
| **PRD.md** | Product Requirements Document |
| **spec.json** | Implementation specification (structured) |
| **AGENT.md** | AI coding agent configuration |
| **Plan.md** | Implementation execution plan |

## Quick Start

1. Open this repo in your AI coding agent (Claude Code, Cursor, exe.dev, etc.)
2. The agent will automatically read \`AGENT.md\` for project rules
3. Follow \`Plan.md\` for step-by-step implementation
`;
}

/** PRD + Spec から AGENT.md を生成する */
export function generateAgentMd(theme: string, prd: Record<string, unknown>, spec: Record<string, unknown>): string {
  const specText = extractSpecRaw(spec) || JSON.stringify(spec, null, 2);

  // PRD からコア機能を抽出
  const coreFeatures = Array.isArray(prd.coreFeatures)
    ? (prd.coreFeatures as Array<{ name: string; description?: string }>)
        .map((f) => `- **${f.name}**: ${f.description || ""}`)
        .join("\n")
    : "";

  // PRD から Non-Goals を抽出
  const nonGoals = Array.isArray(prd.nonGoals) ? (prd.nonGoals as string[]).map((n) => `- ${n}`).join("\n") : "";

  return `# AGENT.md — ${theme}

> This file configures AI coding agents (Claude Code, Cursor, Copilot, etc.) for this project.
> Read this file first before making any changes.

## Project Overview

${prd.problemDefinition || theme}

**Target User**: ${prd.targetUser || "Not specified"}

## Core Features

${coreFeatures || "See PRD.md for details."}

## Non-Goals

${nonGoals || "See PRD.md for details."}

## Implementation Spec

${specText}

## Rules

### MUST (Required)

- **Backend-first**: Implement API endpoints before building UI
- **Real data only**: All data must come from real DB/API connections
- **API-first**: All endpoints must be callable by external services
- **Test coverage**: Write tests for all new code paths
- **Show "Not implemented"**: Display clearly for unfinished features

### NEVER (Prohibited)

- **NEVER use hardcoded/mock data** as a substitute for real DB or API calls
- **NEVER fabricate** sample data, metrics, or statistics — use only real values
- **NEVER silently skip errors** — always handle and surface them to the user
- **NEVER change the meaning** of domain-specific terms by paraphrasing them
- **NEVER commit secrets** (API keys, tokens, passwords) to the repository
- **NEVER implement UI before the backend** that supports it
- **NEVER mark a task as complete** if tests are failing or features are partial

## Workflow

1. Read \`Plan.md\` to understand current progress and next steps
2. Pick the next unchecked task from Plan.md
3. Implement with real data connections (no mocks)
4. Run tests and verify
5. Update Plan.md with progress

## File Structure

| File | Purpose |
|------|---------|
| \`PRD.md\` | Product requirements and acceptance criteria |
| \`spec.json\` | Structured implementation specification |
| \`Plan.md\` | Step-by-step execution plan with progress tracking |
| \`AGENT.md\` | This file — agent configuration and rules |
`;
}

/** PRD + Spec から Plan.md（実行計画）を生成する */
export function generatePlanMd(theme: string, prd: Record<string, unknown>, spec: Record<string, unknown>): string {
  const specRaw = extractSpecRaw(spec);

  // コア機能からタスクリストを生成
  const coreFeatures = Array.isArray(prd.coreFeatures)
    ? (prd.coreFeatures as Array<{ name: string; priority?: string; acceptanceCriteria?: string[] }>)
    : [];

  const featureTasks = coreFeatures
    .map((f, i) => {
      const criteria = Array.isArray(f.acceptanceCriteria)
        ? f.acceptanceCriteria.map((a) => `  - [ ] ${a}`).join("\n")
        : "";
      return `### ${i + 1}. ${f.name} [${f.priority || "P0"}]\n\n${criteria}`;
    })
    .join("\n\n");

  // ユーザーフローから検証手順を生成
  const userFlows = Array.isArray(prd.userFlows)
    ? (prd.userFlows as Array<{ name: string; steps?: string[] }>)
        .map((f) => {
          const steps = Array.isArray(f.steps) ? f.steps.map((s, i) => `${i + 1}. ${s}`).join("\n") : "";
          return `### ${f.name}\n${steps}`;
        })
        .join("\n\n")
    : "";

  // Jobs to be Done
  const jtbd = Array.isArray(prd.jobsToBeDone)
    ? (prd.jobsToBeDone as string[]).map((j, i) => `${i + 1}. ${j}`).join("\n")
    : "";

  return `# Plan.md — ${theme}

> Execution plan for AI coding agents. Update this file as you make progress.
> Generated by [DeepForm](https://deepform.exe.xyz)

## Purpose

${prd.problemDefinition || theme}

**Target User**: ${prd.targetUser || "Not specified"}

## Jobs to be Done

${jtbd || "See PRD.md for details."}

## Implementation Tasks

${featureTasks || "See PRD.md for feature details."}

## Technical Setup

\`\`\`
${specRaw || "See spec.json for technical details."}
\`\`\`

## Validation — User Flows

${userFlows || "See PRD.md for user flow details."}

## Progress Log

<!-- Update this section as you implement features -->

| Date | What was done | Status |
|------|---------------|--------|
| — | Project initialized with DeepForm | Done |

## Notes

- Follow AGENT.md for development rules and conventions
- Check off tasks as you complete them
- Add notes about decisions and blockers in this section
`;
}

// POST /sessions/:id/github-save — Save PRD & spec to GitHub repo
githubSaveRoutes.post("/sessions/:id/github-save", async (c) => {
  try {
    // 1. 認証チェック
    const user = c.get("user");
    if (!user) {
      return c.json({ error: "ログインが必要です" }, 401);
    }

    // 2. GitHub トークンの存在チェック
    const userRow = await db.selectFrom("users").select(["github_token"]).where("id", "=", user.id).executeTakeFirst();
    if (!userRow?.github_token) {
      return c.json({ error: "GitHub 連携が必要です。GitHub でログインしてください。" }, 400);
    }

    // 3. リクエストボディからオプション取得（ボディなしでも OK）
    const body = await c.req.json().catch(() => null);
    const repoName: string | undefined = body?.repoName;

    // 4. セッション所有権チェック
    const result = await getOwnedSession(c);
    if (isResponse(result)) return result;
    const session = result;
    const id = session.id;

    // 5. 分析結果の存在チェック
    const prdRow = await db
      .selectFrom("analysis_results")
      .select("data")
      .where("session_id", "=", id)
      .where("type", "=", ANALYSIS_TYPE.PRD)
      .executeTakeFirst();
    const specRow = await db
      .selectFrom("analysis_results")
      .select("data")
      .where("session_id", "=", id)
      .where("type", "=", ANALYSIS_TYPE.SPEC)
      .executeTakeFirst();

    if (!prdRow || !specRow) {
      return c.json({ error: "PRD と実装仕様を先に生成してください" }, 400);
    }

    const prdData = JSON.parse(prdRow.data);
    const specData = JSON.parse(specRow.data);

    // PRD Markdown を生成
    const prd = prdData.prd || prdData;
    const prdMarkdown = generatePRDMarkdown(prd, session.theme);

    // spec の raw テキストを抽出
    const specRaw = extractSpecRaw(specData) || JSON.stringify(specData, null, 2);

    // 6. ファイルを生成（同期関数は先に実行、LLM 呼び出しのみ await）
    const agentMd = generateAgentMd(session.theme, prd, specData);
    const planMd = generatePlanMd(session.theme, prd, specData);
    const readme = await generateReadme(session.theme, prdMarkdown, specRaw);

    // 7. GitHub に保存
    const saveResult = await saveToGitHub({
      token: userRow.github_token,
      sessionId: id,
      theme: session.theme,
      files: [
        { path: "README.md", content: readme },
        { path: "PRD.md", content: prdMarkdown },
        { path: "spec.json", content: JSON.stringify(specData, null, 2) },
        { path: "AGENT.md", content: agentMd },
        { path: "Plan.md", content: planMd },
      ],
      existingRepoUrl: session.github_repo_url,
      repoName,
    });

    // 8. github_repo_url を保存
    await db
      .updateTable("sessions")
      .set({ github_repo_url: saveResult.repoUrl, updated_at: now() })
      .where("id", "=", id)
      .execute();

    return c.json(saveResult);
  } catch (e) {
    console.error("GitHub save error:", e);
    const message = e instanceof Error ? e.message : "Internal Server Error";
    // トークン期限切れの場合
    if (message.includes("401")) {
      return c.json({ error: "GitHub トークンが期限切れです。再度ログインしてください。" }, 401);
    }
    return c.json({ error: message }, 500);
  }
});
