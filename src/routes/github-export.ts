import { type Context, Hono } from "hono";
import { ZodError } from "zod";
import { db } from "../db.ts";
import type { Session, User } from "../types.ts";
import { exportIssuesSchema } from "../validation.ts";

type AppEnv = { Variables: { user: User | null } };
const githubExportRoutes = new Hono<AppEnv>();

// ---------------------------------------------------------------------------
// Helper: format Zod validation errors
// ---------------------------------------------------------------------------

function formatZodError(error: ZodError): string {
  return error.issues.map((e) => e.message).join(", ");
}

// ---------------------------------------------------------------------------
// Helper: build Issue body from a coreFeature
// ---------------------------------------------------------------------------

interface CoreFeature {
  name: string;
  description: string;
  priority: string;
  acceptanceCriteria?: string[];
  edgeCases?: string[];
}

function buildIssueBody(feature: CoreFeature): string {
  const lines: string[] = [];

  lines.push("## 概要");
  lines.push(feature.description || "");
  lines.push("");

  lines.push("## 受け入れ基準");
  if (feature.acceptanceCriteria?.length) {
    for (const ac of feature.acceptanceCriteria) {
      lines.push(`- [ ] ${ac}`);
    }
  } else {
    lines.push("- (なし)");
  }
  lines.push("");

  lines.push("## エッジケース");
  if (feature.edgeCases?.length) {
    for (const ec of feature.edgeCases) {
      lines.push(`- ${ec}`);
    }
  } else {
    lines.push("- (なし)");
  }
  lines.push("");

  lines.push("---");
  lines.push("_Generated by DeepForm from PRD_");

  return lines.join("\n");
}

// ---------------------------------------------------------------------------
// Helper: map priority to label name
// ---------------------------------------------------------------------------

function priorityLabel(priority: string): string {
  const map: Record<string, string> = {
    must: "priority: must",
    should: "priority: should",
    could: "priority: could",
  };
  return map[priority.toLowerCase()] || `priority: ${priority.toLowerCase()}`;
}

// ---------------------------------------------------------------------------
// Helper: ensure label exists on the repo
// ---------------------------------------------------------------------------

async function ensureLabel(owner: string, repo: string, token: string, labelName: string): Promise<void> {
  const colorMap: Record<string, string> = {
    "priority: must": "e11d48",
    "priority: should": "f59e0b",
    "priority: could": "22c55e",
  };

  const res = await fetch(
    `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/labels/${encodeURIComponent(labelName)}`,
    {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
      },
    },
  );

  if (res.status === 200) return; // label already exists

  // Create the label
  await fetch(`https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/labels`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: labelName,
      color: colorMap[labelName] || "cccccc",
      description: `DeepForm PRD priority: ${labelName.split(": ")[1] || labelName}`,
    }),
  });
  // Ignore errors (label may already exist from a race condition, or permission issue)
}

// ---------------------------------------------------------------------------
// POST /sessions/:id/export-issues — Export PRD coreFeatures as GitHub Issues
// ---------------------------------------------------------------------------

githubExportRoutes.post("/sessions/:id/export-issues", async (c: Context<AppEnv>) => {
  try {
    // Auth check
    const user = c.get("user");
    if (!user) return c.json({ error: "ログインが必要です" }, 401);

    // Ownership check
    const session = db.prepare("SELECT * FROM sessions WHERE id = ?").get(c.req.param("id")) as unknown as
      | Session
      | undefined;
    if (!session) return c.json({ error: "Session not found" }, 404);
    if (session.user_id !== user.id) return c.json({ error: "アクセス権限がありません" }, 403);

    // Validate request body
    const body = await c.req.json();
    const { repoOwner, repoName, token } = exportIssuesSchema.parse(body);

    // Get PRD data
    const prdRow = db
      .prepare("SELECT data FROM analysis_results WHERE session_id = ? AND type = ?")
      .get(session.id, "prd") as unknown as { data: string } | undefined;
    if (!prdRow) return c.json({ error: "PRDが生成されていません。先にPRD生成を実行してください" }, 400);

    const prdData = JSON.parse(prdRow.data);
    const prd = prdData.prd || prdData;
    const coreFeatures: CoreFeature[] = prd.coreFeatures || [];

    if (coreFeatures.length === 0) {
      return c.json({ error: "PRDにコア機能が含まれていません" }, 400);
    }

    // Ensure priority labels exist
    const uniquePriorities = [...new Set(coreFeatures.map((f) => priorityLabel(f.priority)))];
    await Promise.all(uniquePriorities.map((label) => ensureLabel(repoOwner, repoName, token, label)));

    // Create issues
    const created: Array<{ number: number; title: string; url: string }> = [];
    const errors: Array<{ feature: string; error: string }> = [];

    for (const feature of coreFeatures) {
      try {
        const issueBody = buildIssueBody(feature);
        const label = priorityLabel(feature.priority);

        const res = await fetch(
          `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/issues`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${token}`,
              Accept: "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              title: feature.name,
              body: issueBody,
              labels: [label],
            }),
          },
        );

        if (!res.ok) {
          const errData = await res.json().catch(() => ({}));
          errors.push({
            feature: feature.name,
            error: (errData as { message?: string }).message || `HTTP ${res.status}`,
          });
          continue;
        }

        const issueData = (await res.json()) as { number: number; title: string; html_url: string };
        created.push({
          number: issueData.number,
          title: issueData.title,
          url: issueData.html_url,
        });
      } catch (e) {
        errors.push({
          feature: feature.name,
          error: (e as Error).message,
        });
      }
    }

    return c.json({ created, errors });
  } catch (e) {
    if (e instanceof SyntaxError) return c.json({ error: "Invalid JSON" }, 400);
    if (e instanceof ZodError) return c.json({ error: formatZodError(e) }, 400);
    console.error("Export issues error:", e);
    return c.json({ error: (e as Error).message }, 500);
  }
});

export { githubExportRoutes };
