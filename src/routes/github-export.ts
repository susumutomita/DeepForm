import { type Context, Hono } from "hono";
import { ZodError } from "zod";
import { db } from "../db.ts";
import type { Session, User } from "../types.ts";
import { createRepoSchema, exportIssuesSchema } from "../validation.ts";

type AppEnv = { Variables: { user: User | null } };
const githubExportRoutes = new Hono<AppEnv>();

function formatZodError(error: ZodError): string {
  return error.issues.map((e) => e.message).join(", ");
}

function getGitHubToken(userId: string): string | null {
  const row = db.prepare("SELECT github_token FROM users WHERE id = ?").get(userId) as
    | { github_token: string | null }
    | undefined;
  return row?.github_token ?? null;
}

interface CoreFeature {
  name: string;
  description: string;
  priority: string;
  acceptanceCriteria?: string[];
  edgeCases?: string[];
}

function buildIssueBody(feature: CoreFeature): string {
  const lines: string[] = [];
  lines.push("## 概要");
  lines.push(feature.description || "");
  lines.push("");
  lines.push("## 受け入れ基準");
  if (feature.acceptanceCriteria?.length) {
    for (const ac of feature.acceptanceCriteria) lines.push(`- [ ] ${ac}`);
  } else {
    lines.push("- (なし)");
  }
  lines.push("");
  lines.push("## エッジケース");
  if (feature.edgeCases?.length) {
    for (const ec of feature.edgeCases) lines.push(`- ${ec}`);
  } else {
    lines.push("- (なし)");
  }
  lines.push("");
  lines.push("---");
  lines.push("_Generated by DeepForm from PRD_");
  return lines.join("\n");
}

function priorityLabel(priority: string): string {
  const map: Record<string, string> = {
    must: "priority: must",
    should: "priority: should",
    could: "priority: could",
  };
  return map[priority.toLowerCase()] || `priority: ${priority.toLowerCase()}`;
}

async function ensureLabel(owner: string, repo: string, token: string, labelName: string): Promise<void> {
  const colorMap: Record<string, string> = {
    "priority: must": "e11d48",
    "priority: should": "f59e0b",
    "priority: could": "22c55e",
  };
  const res = await fetch(
    `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/labels/${encodeURIComponent(labelName)}`,
    {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
      },
    },
  );
  if (res.status === 200) return;
  await fetch(`https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/labels`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: labelName,
      color: colorMap[labelName] || "cccccc",
      description: `DeepForm PRD priority: ${labelName.split(": ")[1] || labelName}`,
    }),
  });
}

async function exportIssuesToRepo(
  session: Session,
  repoOwner: string,
  repoName: string,
  token: string,
): Promise<{
  created: Array<{ number: number; title: string; url: string }>;
  errors: Array<{ feature: string; error: string }>;
}> {
  const prdRow = db
    .prepare("SELECT data FROM analysis_results WHERE session_id = ? AND type = ?")
    .get(session.id, "prd") as unknown as { data: string } | undefined;
  if (!prdRow) throw new Error("PRDが生成されていません。先にPRD生成を実行してください");

  const prdData = JSON.parse(prdRow.data);
  const prd = prdData.prd || prdData;
  const coreFeatures: CoreFeature[] = prd.coreFeatures || [];
  if (coreFeatures.length === 0) throw new Error("PRDにコア機能が含まれていません");

  const uniquePriorities = [...new Set(coreFeatures.map((f) => priorityLabel(f.priority)))];
  await Promise.all(uniquePriorities.map((label) => ensureLabel(repoOwner, repoName, token, label)));

  const created: Array<{ number: number; title: string; url: string }> = [];
  const errors: Array<{ feature: string; error: string }> = [];

  for (const feature of coreFeatures) {
    try {
      const issueBody = buildIssueBody(feature);
      const label = priorityLabel(feature.priority);
      const res = await fetch(
        `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/issues`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ title: feature.name, body: issueBody, labels: [label] }),
        },
      );
      if (!res.ok) {
        const errData = await res.json().catch(() => ({}));
        errors.push({
          feature: feature.name,
          error: (errData as { message?: string }).message || `HTTP ${res.status}`,
        });
        continue;
      }
      const issueData = (await res.json()) as { number: number; title: string; html_url: string };
      created.push({ number: issueData.number, title: issueData.title, url: issueData.html_url });
    } catch (e) {
      errors.push({ feature: feature.name, error: (e as Error).message });
    }
  }
  return { created, errors };
}

// GET /github/repos — List user's GitHub repos
githubExportRoutes.get("/github/repos", async (c: Context<AppEnv>) => {
  const user = c.get("user");
  if (!user) return c.json({ error: "ログインが必要です" }, 401);

  const token = getGitHubToken(user.id);
  if (!token) {
    return c.json({ error: "GitHubアカウントが連携されていません。GitHub でサインインしてください。" }, 400);
  }

  try {
    const repos: Array<{ full_name: string; name: string; owner: string }> = [];
    let page = 1;
    const perPage = 100;
    while (page <= 3) {
      const res = await fetch(
        `https://api.github.com/user/repos?sort=updated&per_page=${perPage}&page=${page}&affiliation=owner,organization_member`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          },
        },
      );
      if (!res.ok) {
        const errData = await res.json().catch(() => ({}));
        return c.json(
          { error: (errData as { message?: string }).message || `GitHub API error: ${res.status}` },
          res.status as 400,
        );
      }
      const data = (await res.json()) as Array<{
        full_name: string;
        name: string;
        owner: { login: string };
        permissions?: { push?: boolean };
      }>;
      for (const repo of data) {
        if (repo.permissions?.push !== false) {
          repos.push({ full_name: repo.full_name, name: repo.name, owner: repo.owner.login });
        }
      }
      if (data.length < perPage) break;
      page++;
    }
    return c.json(repos);
  } catch (e) {
    console.error("GitHub repos fetch error:", e);
    return c.json({ error: (e as Error).message }, 500);
  }
});

// POST /sessions/:id/export-issues — Export PRD coreFeatures as GitHub Issues
githubExportRoutes.post("/sessions/:id/export-issues", async (c: Context<AppEnv>) => {
  try {
    const user = c.get("user");
    if (!user) return c.json({ error: "ログインが必要です" }, 401);

    const session = db.prepare("SELECT * FROM sessions WHERE id = ?").get(c.req.param("id")) as unknown as
      | Session
      | undefined;
    if (!session) return c.json({ error: "Session not found" }, 404);
    if (session.user_id !== user.id) return c.json({ error: "アクセス権限がありません" }, 403);

    const body = await c.req.json();
    const { repoOwner, repoName } = exportIssuesSchema.parse(body);

    const token = getGitHubToken(user.id);
    if (!token) {
      return c.json({ error: "GitHubアカウントが連携されていません。GitHub でサインインしてください。" }, 400);
    }

    const result = await exportIssuesToRepo(session, repoOwner, repoName, token);
    return c.json(result);
  } catch (e) {
    if (e instanceof SyntaxError) return c.json({ error: "Invalid JSON" }, 400);
    if (e instanceof ZodError) return c.json({ error: formatZodError(e) }, 400);
    if (e instanceof Error && (e.message.includes("PRD") || e.message.includes("コア機能"))) {
      return c.json({ error: e.message }, 400);
    }
    console.error("Export issues error:", e);
    return c.json({ error: (e as Error).message }, 500);
  }
});

// POST /sessions/:id/create-repo-and-export — Create a new repo and export issues
githubExportRoutes.post("/sessions/:id/create-repo-and-export", async (c: Context<AppEnv>) => {
  try {
    const user = c.get("user");
    if (!user) return c.json({ error: "ログインが必要です" }, 401);

    const session = db.prepare("SELECT * FROM sessions WHERE id = ?").get(c.req.param("id")) as unknown as
      | Session
      | undefined;
    if (!session) return c.json({ error: "Session not found" }, 404);
    if (session.user_id !== user.id) return c.json({ error: "アクセス権限がありません" }, 403);

    const body = await c.req.json();
    const { name, description, isPrivate } = createRepoSchema.parse(body);

    const token = getGitHubToken(user.id);
    if (!token) {
      return c.json({ error: "GitHubアカウントが連携されていません。GitHub でサインインしてください。" }, 400);
    }

    const createRes = await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name,
        description: description || `Created by DeepForm for: ${session.theme}`,
        private: isPrivate ?? false,
        auto_init: true,
      }),
    });

    if (!createRes.ok) {
      const errData = await createRes.json().catch(() => ({}));
      return c.json(
        { error: `リポジトリの作成に失敗しました: ${(errData as { message?: string }).message || createRes.status}` },
        createRes.status as 400,
      );
    }

    const repoData = (await createRes.json()) as {
      full_name: string;
      name: string;
      owner: { login: string };
      html_url: string;
    };

    const result = await exportIssuesToRepo(session, repoData.owner.login, repoData.name, token);
    return c.json({ repo: { fullName: repoData.full_name, url: repoData.html_url }, ...result });
  } catch (e) {
    if (e instanceof SyntaxError) return c.json({ error: "Invalid JSON" }, 400);
    if (e instanceof ZodError) return c.json({ error: formatZodError(e) }, 400);
    if (e instanceof Error && (e.message.includes("PRD") || e.message.includes("コア機能"))) {
      return c.json({ error: e.message }, 400);
    }
    console.error("Create repo and export error:", e);
    return c.json({ error: (e as Error).message }, 500);
  }
});

export { githubExportRoutes };
